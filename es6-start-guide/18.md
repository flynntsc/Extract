## Class

### Class的基本语法



```
function Point(x,y){
  this.x = x;
  this.y = y;
}

Point.prototype.toString = function () {
  return '(' + this.x + ', ' + this.y + ')';
}

// Es6改写

class Point {

  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }

}
```

```
// Es6均不可枚举，但Es5的toString就可以
class Point {
  constructor(x, y) {
    // ...
  }

  toString() {
    // ...
  }
}

Object.keys(Point.prototype)
// []
Object.getOwnPropertyNames(Point.prototype)
// ["constructor","toString"]
```

```
// 类的属性名可以用表达式
let methodName = "getArea";
class Square{
  constructor(length) {
    // ...
  }

  [methodName]() {
    // ...
  }
}
```


```
// constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。
class Foo {
  constructor() {
    return Object.create(null);
  }
}

new Foo() instanceof Foo
// false
```

```
// 表达式定义
// 注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。
const MyClass = class Me {
  getClassName() {
    return Me.name;
  }
};
```

```
// 立即执行函数
let person = new class {
  constructor(name) {
    this.name = name;
  }

  sayName() {
    console.log(this.name);
  }
}("张三");

person.sayName(); // "张三"
```

```
// 与Es5不同，Class不存在变量提升（hoist）
// 必须先定义（按规范来就是）
new Foo(); // ReferenceError
class Foo {}

{
  let Foo = class {};
  class Bar extends Foo {
  }
}
```

### Class的继承


```
class Point{...}
class ColorPoint extends Point {

  constructor(x, y, color) {
    super(x, y); // 调用父类的constructor(x, y);必须项，否则报错
    this.color = color;
  }

  toString() {
    return this.color + ' ' + super.toString(); // 调用父类的toString()
  }

}
// super === Point
```

ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。


```
class A {
}
class B extends A {
}
B.__proto__ === A // true // 子类的__proto__总是指向父类
B.prototype.__proto__ === A.prototype // true

// 原理如下

class A {
}
class B {
}
// B的实例继承A的实例
Object.setPrototypeOf(B.prototype, A.prototype);
// B继承A的静态属性
Object.setPrototypeOf(B, A);
```

```
// 对象一章
Object.setPrototypeOf = function (obj, proto) {
  obj.__proto__ = proto;
  return obj;
}


Object.setPrototypeOf(B.prototype, A.prototype);
// 等同于
B.prototype.__proto__ = A.prototype;

Object.setPrototypeOf(B, A);
// 等同于
B.__proto__ = A;


B.prototype = new A();
// 等同于
B.prototype.__proto__ = A.prototype;
```

```
class B extends A {
}
// A可以是任意函数（均有prototype）
```






































